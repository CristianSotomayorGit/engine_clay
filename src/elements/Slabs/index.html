<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta
          name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
  />
  <meta http-equiv="X-UA-Compatible" content="ie=edge"/>
  <link rel="stylesheet" href="../../../resources/styles.css"/>
  <link rel="icon" type="image/x-icon" href="../../../resources/favicon.ico"/>
  <title>Components | Hello world</title>
</head>
<body>
<canvas class="full-screen" id="container"></canvas>

<script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.135.0/build/three.module.js",
          "three/examples/jsm/libs/lil-gui.module.min": "https://unpkg.com/three@0.135.0/examples/jsm/libs/lil-gui.module.min.js",
          "three/examples/jsm/controls/OrbitControls": "https://unpkg.com/three@0.135.0/examples/jsm/controls/OrbitControls.js",
          "three/examples/jsm/controls/TransformControls": "https://unpkg.com/three@0.135.0/examples/jsm/controls/TransformControls.js",
          "stats.js/src/Stats.js": "https://unpkg.com/stats-js@1.0.1/src/Stats.js",
          "client-zip": "https://unpkg.com/client-zip@2.3.0/index.js"
        }
      }
</script>
<script type="module">
	import * as THREE from 'three';
	import { SimpleThreeScene } from '../../../resources/simple-three-scene.js';
	// import {TransformControls} from "three/examples/jsm/controls/TransformControls";
	import * as OBC from '../../../resources/openbim-clay.js';
	import * as dat from 'three/examples/jsm/libs/lil-gui.module.min';

	const canvas = document.getElementById('container');
	const world = new SimpleThreeScene(canvas);

	const slabs = new OBC.Slabs();
	world.scene.add(slabs.extrusions.faces.mesh);
	world.scene.add(slabs.lines.mesh);
	world.scene.add(slabs.lines.vertices.mesh);

	const settings = {
		save: "S",
    edit: "E",
    newSlab: "D",
    createPoint: "C (In create mode)",
    select: "A (In create mode)",
    move: "G (In create mode)"
  }

	const floorPlaneGeom = new THREE.PlaneGeometry(1000, 1000);
	const floorPlaneMaterial = new THREE.MeshLambertMaterial({ transparent: true, opacity: 0.7 });
	const floorPlane = new THREE.Mesh(floorPlaneGeom, floorPlaneMaterial);
	floorPlane.rotation.x = -Math.PI / 2;
	floorPlane.position.y += 0.01;
	floorPlane.visible = false;
	world.scene.add(floorPlane);

	const newSlabPoints = [];
	const newSlabLines = [];
	const polylines = [];

	// default | create
	let mode = 'default';
	let editedSlab = null;

	window.addEventListener('keydown', (event) => {
		if (event.code === 'Escape') {
			deselectPoints();
			cancelSlabDraw();
		} else if (event.code === 'Delete') {

		} else if (event.code === 'KeyE') {
			editSlab();
		} else if (event.code === 'KeyD') {
			setCreateMode(true);
		} else if (event.code === 'KeyC') {
			addPoint();
		} else if (event.code === 'KeyS') {
      saveSlab();
		} else if (event.code === 'KeyA') {
			selectPoint(event);
		}
		else if (event.code === 'KeyG') {
			toggleMoveMode();
		}
	});

	let found;
	let firstPointID;
	let isClosingLines = false;

	function setCreateMode(active) {
		const isCreateActive = mode === 'create';
		if (isCreateActive === active) return;

		floorPlane.visible = active;

		if (active) {
			window.addEventListener('mousemove', updateMouse);
		} else {
			window.removeEventListener('mousemove', updateMouse);
		}
		mode = active ? 'create' : 'default';
	}

	// Draw polyline as rectangle
  // Split line in polyline (adding a point)
  // Remove point in polyline
  // Select line and polyline
  // Set base plane
  // Snapping: draw ortho, basic references

	function editSlab() {
		if(mode !== "default") return;
		const hit = world.castRay([slabs.extrusions.faces.mesh]);
		if(!hit.length) return;
		const index = hit[0].faceIndex;
		const slabID = slabs.getFromIndex(index);
		editedSlab = slabID;
		if(slabID === undefined) return;
		slabs.removeExtrusion(slabID);
		const slab = slabs.list[slabID];
		polylines.push(...slab.polylines);
		setCreateMode(true);
  }

	function saveSlab() {
		if(!polylines.length) return;
		if(editedSlab !== null) {
			slabs.setPolylines(editedSlab, polylines);
			slabs.regenerate([editedSlab]);
			setCreateMode(false);
			polylines.length = 0;
			editedSlab = null;
			deselectPoints();
			return;
    }
		slabs.add(polylines, 0.3);
		slabs.extrusions.faces.mesh.geometry.computeBoundingSphere();
		setCreateMode(false);
		polylines.length = 0;
		deselectPoints();
  }

	function updateMouse() {
		const hit = world.castRay([floorPlane, slabs.lines.vertices.mesh]);

		if (!hit.length) {
			found = null;
			return;
		}

		found = hit;

		if (mode === 'create' && newSlabPoints.length) {
			moveLastPoint();
		}
	}

	function moveLastPoint() {
		if (!found) {
			isClosingLines = false;
			return;
		}

		const lastPoint = newSlabPoints[newSlabPoints.length - 1];

		let foundFirstPoint = false;
		let foundBasePlane;

		const index = slabs.lines.vertices.idMap.getIndex(firstPointID);
		for(const item of found) {
			if(item.object === floorPlane) {
				foundBasePlane = item;
      }
			if(item.object === slabs.lines.vertices.mesh && item.index === index) {
				foundFirstPoint = true;
			}
    }

		if (foundFirstPoint) {
				const coords = slabs.lines.vertices.get(firstPointID);
				if (coords) {
					const [x, y, z] = coords;
					slabs.lines.setPoint(lastPoint, [x, y, z]);
					isClosingLines = true;
					return;
				}
		} else if(foundBasePlane) {
			const { x, y, z } = foundBasePlane.point;
			slabs.lines.setPoint(lastPoint, [x, y, z]);
    }

		isClosingLines = false;
	}

	function addPoint() {
		if(mode !== "create") return;
		if (!found) return;

		if(isClosingLines) {
			finishPolyline();
			return;
		}

		const { x, y, z } = found[0].point;

		if (!newSlabPoints.length) {
			const [firstPoint] = slabs.lines.addPoints([[x, y, z]]);
			firstPointID = firstPoint;
			newSlabPoints.push(firstPoint);
		}

		const previousPoint = newSlabPoints[newSlabPoints.length - 1];
		const [newPoint] = slabs.lines.addPoints([[x, y, z]]);
		newSlabPoints.push(newPoint);

		const [newLine] = slabs.lines.add([previousPoint, newPoint]);
		newSlabLines.push(newLine);

		slabs.lines.vertices.mesh.geometry.computeBoundingSphere();
	}

	function finishPolyline() {

		const last = newSlabPoints.pop();
		slabs.lines.removePoints([last]);
		newSlabLines.pop();

		const lastPoint = newSlabPoints[newSlabPoints.length - 1];
		const firstPoint = newSlabPoints[0];
		const [newLine] = slabs.lines.add([lastPoint, firstPoint]);
		newSlabLines.push(newLine);


		const polyline = slabs.addPolyline(newSlabLines);
    polylines.push(polyline);

		newSlabLines.length = 0;
		newSlabPoints.length = 0;
		isClosingLines = false;
	}

	function selectPoint(event) {
		slabs.lines.vertices.mesh.geometry.computeBoundingSphere();
		if(mode !== "create") return;
		const hit = world.castRay([slabs.lines.vertices.mesh]);
		if(!hit.length) return;
		const index = hit[0].index;
		const pointID = slabs.lines.vertices.idMap.getId(index);
		if(!event.shiftKey) {
			deselectPoints();
    }
		slabs.lines.vertices.select(true, [pointID]);
	}

	const currentTransform = new THREE.Matrix4();
	const previousTransform = new THREE.Matrix4();
	let isMoving = false;
	let firstMove = true;

	function toggleMoveMode() {
		isMoving = !isMoving;
		if(isMoving) {
			window.addEventListener("mousemove", moveSelectedPoints)
    } else {
			firstMove = true;
      window.removeEventListener("mousemove", moveSelectedPoints)
    }
  }

	function moveSelectedPoints() {
		const hit = world.castRay([floorPlane]);
		if (!hit.length) return;
		currentTransform.setPosition(hit[0].point);
		if(firstMove) {
			previousTransform.setPosition(hit[0].point);
			firstMove = false;
		}
		const temp = currentTransform.clone();
		currentTransform.multiply(previousTransform.invert());
		slabs.lines.transform(currentTransform);
		previousTransform.copy(temp);
	}

	function deselectPoints() {
		slabs.lines.vertices.select(false);
  }

	function cancelSlabDraw() {
		if(editedSlab !== null) {
			saveSlab();
			return;
    }
		const pointsToRemove = [...newSlabPoints];
		for(const id of polylines) {
			const polyline = slabs.polylines[id];
			for(const lineID of polyline.lines) {
				const line = slabs.lines.list[lineID]
        pointsToRemove.push(line.end);
      }
    }

		slabs.lines.removePoints(pointsToRemove);

		newSlabPoints.length = 0;
		newSlabLines.length = 0;
		polylines.length = 0;
		setCreateMode(false);
  }


	// Set up GUI

	const gui = new dat.GUI();

	gui.add(settings, "newSlab").name("Create new slab");
	gui.add(settings, "save").name("Save slab");
	gui.add(settings, "edit").name("Edit slab");
	gui.add(settings, "createPoint").name("Create point");
	gui.add(settings, "select").name("Select");
	gui.add(settings, "move").name("Move");

</script>
</body>
</html>
