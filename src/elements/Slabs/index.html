<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta
          name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
  />
  <meta http-equiv="X-UA-Compatible" content="ie=edge"/>
  <link rel="stylesheet" href="../../../resources/styles.css"/>
  <link rel="icon" type="image/x-icon" href="../../../resources/favicon.ico"/>
  <title>Components | Hello world</title>
</head>
<body>
<canvas class="full-screen" id="container"></canvas>

<script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.135.0/build/three.module.js",
          "three/examples/jsm/libs/lil-gui.module.min": "https://unpkg.com/three@0.135.0/examples/jsm/libs/lil-gui.module.min.js",
          "three/examples/jsm/controls/OrbitControls": "https://unpkg.com/three@0.135.0/examples/jsm/controls/OrbitControls.js",
          "three/examples/jsm/controls/TransformControls": "https://unpkg.com/three@0.135.0/examples/jsm/controls/TransformControls.js",
          "stats.js/src/Stats.js": "https://unpkg.com/stats-js@1.0.1/src/Stats.js",
          "client-zip": "https://unpkg.com/client-zip@2.3.0/index.js"
        }
      }




</script>
<script type="module">
	import * as THREE from 'three';
	import { SimpleThreeScene } from '../../../resources/simple-three-scene.js';
	// import {TransformControls} from "three/examples/jsm/controls/TransformControls";
	import * as OBC from '../../../resources/openbim-clay.js';
	import * as dat from 'three/examples/jsm/libs/lil-gui.module.min';

	const canvas = document.getElementById('container');
	const world = new SimpleThreeScene(canvas);

	const slabs = new OBC.Slabs();
	world.scene.add(slabs.extrusions.faces.mesh);
	world.scene.add(slabs.lines.mesh);
	world.scene.add(slabs.lines.vertices.mesh);

	const settings = {
		interior: false
  }


	const floorPlaneGeom = new THREE.PlaneGeometry(1000, 1000);
	const floorPlaneMaterial = new THREE.MeshLambertMaterial({ transparent: true, opacity: 0.7 });
	const floorPlane = new THREE.Mesh(floorPlaneGeom, floorPlaneMaterial);
	floorPlane.rotation.x = -Math.PI / 2;
	floorPlane.position.y += 0.01;
	floorPlane.visible = false;
	world.scene.add(floorPlane);

	const newSlabPoints = [];
	const newSlabLines = [];
	const polylines = [];

	// default | create
	let mode = 'default';
	let selectedSlab = null;

	window.addEventListener('keydown', (event) => {
		if (event.code === 'Escape') {

		} else if (event.code === 'Delete') {

		} else if (event.code === 'KeyE') {
			editSlab();
		} else if (event.code === 'KeyD') {
			setCreateMode(true);
		} else if (event.code === 'KeyC') {
			addPoint();
		} else if (event.code === 'KeyS') {
      saveSlab();
		}
	});

	let found;
	let firstPointID;
	let isClosingLines = false;

	function setCreateMode(active) {
		const isCreateActive = mode === 'create';
		if (isCreateActive === active) return;

		floorPlane.visible = active;

		if (active) {
			window.addEventListener('mousemove', updateMouse);
		} else {
			window.removeEventListener('mousemove', updateMouse);
		}
		mode = active ? 'create' : 'default';
	}

	function editSlab() {
		if(mode === "create") return;
		const hit = world.castRay([slabs.extrusions.faces.mesh]);
		if(!hit.length) return;
		const index = hit[0].faceIndex;
		const slabID = slabs.getFromIndex(index);
		if(slabID === undefined) return;
		slabs.removeExtrusion(slabID);
		const slab = slabs.list[slabID];
		polylines.push(...slab.polylines);
		setCreateMode(true);
  }

	function saveSlab() {
		if(!polylines.length) return;
		slabs.add(polylines, 0.3);
		slabs.extrusions.faces.mesh.geometry.computeBoundingSphere();
		setCreateMode(false);
		polylines.length = 0;
  }

	function updateMouse() {
		const hit = world.castRay([floorPlane, slabs.lines.vertices.mesh]);

		if (!hit.length) {
			found = null;
			return;
		}

		found = hit;

		if (mode === 'create' && newSlabPoints.length) {
			moveLastPoint();
		}
	}

	function moveLastPoint() {
		if (!found) {
			isClosingLines = false;
			return;
		}

		const lastPoint = newSlabPoints[newSlabPoints.length - 1];

		let foundFirstPoint = false;
		let foundBasePlane;

		const index = slabs.lines.vertices.idMap.getIndex(firstPointID);
		for(const item of found) {
			if(item.object === floorPlane) {
				foundBasePlane = item;
      }
			if(item.object === slabs.lines.vertices.mesh && item.index === index) {
				foundFirstPoint = true;
			}
    }

		if (foundFirstPoint) {
				const coords = slabs.lines.vertices.get(firstPointID);
				if (coords) {
					const [x, y, z] = coords;
					slabs.lines.setPoint(lastPoint, [x, y, z]);
					isClosingLines = true;
					return;
				}
		} else if(foundBasePlane) {
			const { x, y, z } = foundBasePlane.point;
			slabs.lines.setPoint(lastPoint, [x, y, z]);
    }

		isClosingLines = false;
	}

	function addPoint() {
		if(mode !== "create") return;
		if (!found) return;

		const { x, y, z } = found[0].point;

		if (!newSlabPoints.length) {
			const [firstPoint] = slabs.lines.addPoints([[x, y, z]]);
			firstPointID = firstPoint;
			newSlabPoints.push(firstPoint);
		}

		if(isClosingLines) {
			finishPolyline();
			return;
		}

		const previousPoint = newSlabPoints[newSlabPoints.length - 1];
		const [newPoint] = slabs.lines.addPoints([[x, y, z]]);
		newSlabPoints.push(newPoint);

		const [newLine] = slabs.lines.add([previousPoint, newPoint]);
		newSlabLines.push(newLine);

		slabs.lines.vertices.mesh.geometry.computeBoundingSphere();


	}

	function finishPolyline() {
		const isInterior = settings.interior;
		const polyline = slabs.addPolyline(newSlabLines, isInterior);
    polylines.push(polyline);

		newSlabLines.length = 0;
		newSlabPoints.length = 0;
		isClosingLines = false;
	}


	// Set up GUI

	const gui = new dat.GUI();
	gui.add(settings, "interior");

</script>
</body>
</html>
